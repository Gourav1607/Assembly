.MODEL SMALL
.486
.DATA
ARR DB ?
MSG1 DB "ENTER THE LIST SIZE (FROM 00H TO FFH): $"
MSG2 DB "ENTER ($"
MSG3 DB ")H ELEMENTS: $"
MSG4 DB "INPUT NUMBER TO BE SEARCHED: $"
MSG5 DB "INPUT NUMBER NOT IN LIST$"
MSG51 DB "INPUT NUMBER IS LESS THAN LIST ELEMENTS$"
MSG52 DB "INPUT NUMBER IS GREATER THAN LIST ELEMENTS$"
MSG6 DB "INPUT NUMBER IN SORTED LIST IS AT INDEX: $" 

.STACK 20H

.CODE
.STARTUP
MOV DX,OFFSET MSG1              ; PRINT MSG1
MOV AH,09H
INT 21H
MOV SI,00H                      ; INTIALIZE COUNTER STORAGE LOCATION
CALL INPUT                      ; INPUT COUNTER
MOV ARR[SI],DL                  ; STORE COUNTER IN ARR[0]
MOV DL,0AH                      ; LINE BREAK
MOV AH,02
INT 21H

MOV DX,OFFSET MSG2              ; PRINT MSG2
MOV AH,09H
INT 21H
CALL OUTPUT        
MOV DX,OFFSET MSG3              ; PRINT MSG3
MOV AH,09H
INT 21H

MOV DL,0AH                      ; LINE BREAK
MOV AH,02
INT 21H

;INC SI                          ; SET FIRST LOCATION OF ELEMENT STORAGE
XOR CX,CX                       ; CLEAR COUNTER REG
MOV CL,ARR[0]                   ; LOAD COUNTER IN CL REG
STORE:  CALL INPUT              ; INPUT ELEMENT
        INC SI                  ; INCREMENT ARR LOCATION
        MOV ARR[SI],DL          ; STORE IN ARR MEMORY
        MOV DL,' '              ; LINE BREAK
        MOV AH,02
        INT 21H
LOOP STORE
MOV DL,0AH
MOV AH,02H
INT 21H
MOV DX,OFFSET MSG4              ; PRINT MSG4
MOV AH,09H
INT 21H

CALL INPUT
MOV BL,DL                       ; INPUT THE NUMBER IN BL
MOV DL,0AH                      ; LINE BREAK
MOV AH,02
INT 21H

MOV CL,ARR[0]                   ; LOAD COUNTER
MOV BP,SI                       ; BACKUP MEM LOCATION IN BP

;--------------- SELECTION SORT --------------

SRT1:   MOV CH,CL
        DEC CH                  ; CHECK IF SORTING COMPLETE
        JZ DONE
        MOV DI,BP               
        MOV AL,ARR[DI]          ; LOAD ELEMENT FOR SORTING COMPARISON
        MOV SI,DI
        
SRT11:  DEC SI
        CMP AL,ARR[SI]          ; COMPARE THE LIST WITH ELEMENT LOADED IN AL
        JAE NXT11
        MOV DL,ARR[SI]          ; SWAP IF CONDITION IS TRUE
        MOV ARR[SI],AL
        MOV AL,DL
        MOV ARR[DI],AL
NXT11:  DEC CH
    JNZ SRT11
DEC BP
DEC CL
JNZ SRT1

DONE: MOV SI,BP         ; LOADING THE FIRST INDEX INTO SI
CMP BL,ARR[SI]          ; TESTING FIRST ELEMENT
JE VALUE                ; IF FIRST ELEMENT THEN JUMP
JB NFND1
XOR AX,AX
MOV AL,ARR[0]
MOV DI,AX
CMP BL,ARR[DI]
JE PRT1
JA NFND2
GO:     MOV AX,DI           ; MOVE GREATER INDEX TO AX
        ADD AX,SI           ; ADD LOWER INDEX TO AX
        SHR AX,1            ; DETERMINE MID INDEX
        CMP AX,SI           ; COMPARE MID INDEX WITH LOWER INDEX
        JE NFND             ; IF EQUAL THEN JUMP TO NOT FOUND STATEMENT
        CMP AX,DI           ; COMPARE MID INDEX WITH HIGHER INDEX
        JE NFND             ; IF EQUAL THEN JUMP TO NOT FOUND STATEMENT
        MOV BP,AX           ; LOAD MID TO BP 
        CMP BL,ARR[BP]      ; COMPARE MID VALUE WITH NUMBER
        JE PRT2             ; IF EQUAL JUMP TO PRINT INDEX
        JG CHNGSI           ; IF BL>ARR[BP] THEN JUMP TO SET NEW MID
        MOV DI,AX           ; ELSE HIGHER INDEX IS MID INDEX
JMP GO
CHNGSI: MOV SI,AX           ; LOWER INDEX IS MID INDEX
JMP GO

NFND1:   MOV DX,OFFSET MSG51
        MOV AH,09
        INT 21H
        JMP FNSH
NFND2:   MOV DX,OFFSET MSG52
        MOV AH,09
        INT 21H
        JMP FNSH
NFND:   MOV DX,OFFSET MSG5
        MOV AH,09
        INT 21H
        JMP FNSH
VALUE:  MOV DX,OFFSET MSG6
        MOV AH,09
        INT 21H
        MOV DX,SI           ; LOAD 1ST INDEX TO PUBLISH
        JMP PRT
PRT1:   MOV DX,OFFSET MSG6
        MOV AH,09
        INT 21H
        MOV DX,DI           ; LOAD LAST INDEX TO PUBLISH 
        JMP PRT
PRT2:   MOV DX,OFFSET MSG6
        MOV AH,09
        INT 21H
        MOV DX,BP           ; LOAD MID INDEX TO PUBLISH
PRT:    MOV ARR[SI],DL
CALL OUTPUT

FNSH:
.EXIT
INPUT PROC NEAR
        MOV AH,01
        INT 21H
        SUB AL,30H
        CMP AL,09
        JBE JUMP01
        SUB AL,07H
JUMP01: MOV DL,AL
        SHL DX,4
        MOV AH,01
        INT 21H
        SUB AL,30H
        CMP AL,09
        JBE JUMP02
        SUB AL,07H
JUMP02: ADD DL,AL
RET
INPUT ENDP

OUTPUT PROC NEAR
        MOV DL,ARR[SI]
        ROL DL,4
        AND DL,0FH
        CMP DL,09
        JBE JUMP07
        ADD DL,07H
JUMP07: ADD DL,30H
        MOV AH,02
        INT 21H

        MOV DL,ARR[SI]
        AND DL,0FH
        CMP DL,09
        JBE JUMP08
        ADD DL,07H
JUMP08: ADD DL,30H
        MOV AH,02
        INT 21H
RET
OUTPUT ENDP        
END

